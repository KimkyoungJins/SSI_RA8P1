/*
 * File Name    : ssi_ep_no_loopback.c
 * Description  : Streams a generated stereo sine wave to the DA7212 codec
 *                using SSI (I2S) on the EK‑RA8P1 board.
 *                All loop‑back (RX) logic has been removed – this build is
 *                transmit‑only and intended for real speaker output.
 *
 * Target HW     : EK‑RA8P1 + DA7212 (on‑board) + Speaker on J33
 * Toolchain     : Renesas e² studio + FSP 5.x
 *
 * 2025‑07‑31 – Initial TX‑only version
 * ---------------------------------------------------------------------------*/

#include "ssi_ep.h"          /* Example‑specific definitions/macros */
#include "hal_data.h"        /* g_i2s_ctrl, g_timer_ctrl, etc. */

/***** Private function prototypes *******************************************/
static void ssi_example_calculate_samples(uint32_t buffer_index);
static void ssi_example_write(void);
static void deinit_gpt(void);
static void deinit_ssi(void);

/* External – DA7212 I2C initialisation (user supplies in another unit) */
fsp_err_t da7212_speaker_init(void);

/***** Globals ***************************************************************/
volatile i2s_event_t g_i2s_event       = I2S_EVENT_TX_EMPTY;   /* Updated in callback */
volatile bool        g_send_data_now   = true;                 /* Main‑loop TX trigger */
volatile bool        g_data_ready      = false;                /* True when buffer filled */
volatile uint8_t     g_buffer_index    = 0;                    /* Ping‑pong index (0/1) */

/* Ping‑pong source buffers (stereo 16‑bit samples) */
static int16_t g_src_buff[2][SSI_STREAMING_EXAMPLE_SAMPLES_PER_CHUNK];

/***** Example entry point (called from main when no RTOS) *******************/
void ssi_entry(void)
{
    fsp_err_t err = FSP_SUCCESS;
    fsp_pack_version_t version = {0};

    /* Print banner */
    R_FSP_VersionGet(&version);
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major,
              version.version_id_b.minor, version.version_id_b.patch);
    APP_PRINT("\r\nTX‑only SSI example – streaming sine wave to DA7212\r\n\r\n");

    /* ---- Initialise peripherals ---------------------------------------- */

    /* 1) Open SSI (I2S) – configuration generated by FSP */
    err = R_SSI_Open(&g_i2s_ctrl, &g_i2s_cfg);
    APP_ERR_TRAP(err);

    /* 2) Open GPT to supply AUDIO_CLK for SSI bit clock generation */
    err = R_GPT_Open(&g_timer_ctrl, &g_timer_cfg);
    APP_ERR_TRAP(err);

    err = R_GPT_Start(&g_timer_ctrl);
    APP_ERR_TRAP(err);

    /* 3) Initialise the DA7212 codec via I2C */
    err = da7212_speaker_init();
    APP_ERR_TRAP(err);

    /* ---- Prime the double buffer with initial samples ------------------- */
    ssi_example_calculate_samples(0);
    ssi_example_calculate_samples(1);

    /* ---- Kick‑off first transfer --------------------------------------- */
    ssi_example_write();

    /* ---- Main application loop ----------------------------------------- */
    while (true)
    {
        /* If callback indicated data wasn’t ready in time, TX from main loop */
        if (g_send_data_now)
        {
            g_send_data_now = false;
            ssi_example_write();
        }

        /* While CPU is free, prepare next buffer */
        if (!g_data_ready)
        {
            ssi_example_calculate_samples(g_buffer_index);   /* Fill idle buffer */
        }

        /* Optional: add application code here */
    }
}

/***** Generate stereo sine wave into selected buffer ************************/
static void ssi_example_calculate_samples(uint32_t buffer_index)
{
    /* Derive sample rate from GPT settings */
    uint32_t pclkd_hz = R_FSP_SystemClockHzGet(FSP_PRIV_CLOCK_PCLKD);
    uint32_t period   = pclkd_hz / g_timer_cfg.period_counts;
    uint32_t fs       = period / (2U * 2U * 16U);   /* See original formula */

    static uint32_t t = 0U;                         /* Running sample index */
    const uint32_t tone_hz = SSI_STREAMING_EXAMPLE_TONE_FREQUENCY_HZ;

    for (uint32_t i = 0; i < SSI_STREAMING_EXAMPLE_SAMPLES_PER_CHUNK / 2U; ++i)
    {
        float angle = 2.0f * (float)M_PI * (float)tone_hz * (float)t / (float)fs;
        ++t;
        int16_t sample = (int16_t)((float)INT16_MAX * sinf(angle));

        /* Write to L & R */
        g_src_buff[buffer_index][2U * i]     = sample;
        g_src_buff[buffer_index][2U * i + 1] = sample;
    }

    g_data_ready = true;        /* Buffer ready for transmission */
}

/***** Transmit one buffer using non‑blocking DMA (TX only) ******************/
static void ssi_example_write(void)
{
    if (!g_data_ready)
    {
        return;     /* Buffer not ready yet – skip */
    }

    size_t bytes = SSI_STREAMING_EXAMPLE_SAMPLES_PER_CHUNK * sizeof(int16_t);

    fsp_err_t err = R_SSI_Write(&g_i2s_ctrl,
                                (uint8_t *) g_src_buff[g_buffer_index],
                                bytes);
    if (FSP_SUCCESS == err)
    {
        /* Switch to alternate buffer for next prepare */
        g_buffer_index = !g_buffer_index;
        g_data_ready   = false;
    }
    else
    {
        APP_PRINT("\r\nR_SSI_Write failed – closing peripherals\r\n");
        deinit_ssi();
        deinit_gpt();
        APP_ERR_TRAP(err);
    }
}

/***** SSI ISR callback ******************************************************/
void i2s_callback(i2s_callback_args_t * p_args)
{
    if ((NULL != p_args) && (I2S_EVENT_TX_EMPTY == p_args->event))
    {
        if (g_data_ready)
        {
            /* Reload from interrupt context if ready */
            ssi_example_write();
        }
        else
        {
            /* Not ready yet – let main loop handle when prepared */
            g_send_data_now = true;
        }
    }
}

/***** Peripheral de‑initialisation ******************************************/
static void deinit_ssi(void)
{
    fsp_err_t err = R_SSI_Close(&g_i2s_ctrl);
    if (FSP_SUCCESS != err)
    {
        APP_PRINT("\r\nR_SSI_Close failed\r\n");
    }
}

static void deinit_gpt(void)
{
    fsp_err_t err = R_GPT_Close(&g_timer_ctrl);
    if (FSP_SUCCESS != err)
    {
        APP_PRINT("\r\nR_GPT_Close failed\r\n");
    }
}
